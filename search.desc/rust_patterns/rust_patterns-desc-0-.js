searchState.loadedDescShard("rust_patterns", 0, "Rust Programming Patterns\nHiding the Backing Implementation of Algorithms and Data …\nPlugin Systems in Rust\nThis macro ensures correct implementation of the …\nInformation Hiding, Encapsulation, and Shared …\nTyped and Type-Erased API\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe “Registry Pattern”\nA boxed <code>RegisteredItem</code>\nGlobal item index counter, keeps track of the index that …\nFor simple applications, just knowing how many items are …\nA trait for items that can be registered (<code>DataPlugin</code>, …\nAdds a new item to the registry. The job of this method is …\nReturns the argument unchanged.\nAn accessor for <code>NEXT_ITEM_INDEX</code>\nFetches an immutable reference to the item <code>R</code> from the …\nFetches a mutable reference to the item <code>R</code> from the …\nThe index of the item in the <code>RegisteredItem</code> list, …\nAcquires a global lock on the next available plugin index, …\nCalls <code>U::from(self)</code>.\nIn this pattern, the <code>RegisteredItem</code>s are stored in a …\nConvenient for debugging.\nCreates a new instance of the item.\nFine-grained Encapsulation and Information Hiding with …\nA “boxed” <code>TypeErasedIndex</code>, use anywhere you need a …\nThe typed <code>Index&lt;T&gt;</code>\nThis trait Encapsulates the type-erased API.\nReturns the argument unchanged.\nGets an immutable reference to the set associated with the …\nGets a mutable reference to the set associated with the <code>key</code>…\nFetching a set only requires the hash.\nFetching a set only requires the hash.\nDoes the index contain the given hash?\nInserts an entity into the set associated with <code>key</code>, …\nInserting a new entity only requires the hash but requires …\nInserting a new <em>value</em> requires the value itself.\nCalls <code>U::from(self)</code>.\nWe store a copy of the value here so that we can iterate …")