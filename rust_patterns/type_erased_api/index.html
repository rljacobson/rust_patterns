<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Typed and Type-Erased API"><title>rust_patterns::type_erased_api - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rust_patterns" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../rust_patterns/index.html">rust_<wbr>patterns</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module type_<wbr>erased_<wbr>api</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#typed-and-type-erased-api" title="Typed and Type-Erased API">Typed and Type-Erased API</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate rust_<wbr>patterns</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">rust_patterns</a></div><h1>Module <span>type_erased_api</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/rust_patterns/type_erased_api.rs.html#1-167">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="typed-and-type-erased-api"><a class="doc-anchor" href="#typed-and-type-erased-api">§</a>Typed and Type-Erased API</h2>
<p>An illustration of a type, a database index, having both a typed and type-erased API.</p>
<p>Sometimes an implementation needs access to a concrete type while providing a type-erased interface. In some situations,
a type-erased interface can provide the same functionality as a typed-API but at some cost, and so you want to provide
both a typed and type-erased interface.</p>
<p>In this context, by <em>typed</em> I mean that a concrete type is known at compile time. Generally
a typed API will be <em>generic</em> over the type but monomorphized at compile time. (Stop
worrying about how monomorphization increases the size of the final binary. And, while
you’re at it, stop obsessing about string copies.) The concrete type is <code>Index&lt;T&gt;</code> (notice
the generic <code>T</code>). The <em>typed</em> API is just the methods provided by <code>impl&lt;T&gt; Index&lt;T&gt;{...}</code>.</p>
<p>A type-erased API, on the other hand, will be monomorphic over a trait object. We define the type-erased API via the
trait <code>TypeErasedIndex</code> (notice the lack of a generic <code>T</code>) and provide a <em>blanket implementation</em> for all <code>Index&lt;T&gt;</code>s.</p>
<p>Notice that it turns out to be convenient to implement many of the methods of the typed
API by deferring to the type-erased API, which is typical. <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">You will want to do this when
you can to keep your code DRY.</a>
Don’t be a slave to the DRY principle; violate it whenever it makes
sense. These rules of thumb are not an excuse to turn off your brain.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Index.html" title="struct rust_patterns::type_erased_api::Index">Index</a></dt><dd>The typed <code>Index&lt;T&gt;</code></dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.TypeErasedIndex.html" title="trait rust_patterns::type_erased_api::TypeErasedIndex">Type<wbr>Erased<wbr>Index</a></dt><dd>This trait Encapsulates the type-erased API.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BxIndex.html" title="type rust_patterns::type_erased_api::BxIndex">BxIndex</a></dt><dd>A “boxed” <code>TypeErasedIndex</code>, use anywhere you need a type-erased <code>Index&lt;T&gt;</code></dd><dt><a class="type" href="type.EntityId.html" title="type rust_patterns::type_erased_api::EntityId">Entity<wbr>Id</a></dt><dt><a class="type" href="type.HashValue.html" title="type rust_patterns::type_erased_api::HashValue">Hash<wbr>Value</a></dt></dl></section></div></main></body></html>