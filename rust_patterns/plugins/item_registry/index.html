<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The “Registry Pattern”"><title>rust_patterns::plugins::item_registry - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rust_patterns" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../rust_patterns/index.html">rust_<wbr>patterns</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module item_<wbr>registry</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-registry-pattern" title="The “Registry Pattern”">The “Registry Pattern”</a><ul><li><a href="#q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data" title="Q: Wait, aren’t you just talking about static variables? Or, aren’t you just talking about lazy initialization of static data?">Q: Wait, aren’t you just talking about static variables? Or, aren’t you just talking about lazy initialization of static data?</a></li><li><a href="#notes" title="Notes">Notes</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rust_<wbr>patterns::<wbr>plugins</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">rust_patterns</a>::<wbr><a href="../index.html">plugins</a></div><h1>Module <span>item_registry</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rust_patterns/plugins/item_registry.rs.html#1-260">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="the-registry-pattern"><a class="doc-anchor" href="#the-registry-pattern">§</a>The “Registry Pattern”</h2>
<p>The “Registry Pattern” is a plugin-like pattern for managing a collection of
<a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> instances such that discovery of items is automatic/implicit.</p>
<p>For our use case, the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s are lazily registered (the allocation or
instantiation of <em>static</em> data) and instantiated (for <em>instance</em> data), but this is not
an essential part of the pattern. What <em>is</em> essential is that the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s
are automatically discovered, even if they are defined in external crates.</p>
<p>In the simplest formulation, the “registry pattern” is just a vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s
each one of which has a static <code>index</code> variable in which is stored its position in
the vector that owns it. We just provide a mechanism for assigning the indices to
the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s at runtime in a logically consistent and thread-safe way
that doesn’t require explicit knowledge of every <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> type that exists.</p>
<p>We define the <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> struct as a wrapper type around the vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>
instances to provide convenient <a href="struct.RegisteredItems.html#method.get_item" title="method rust_patterns::plugins::item_registry::RegisteredItems::get_item"><code>RegisteredItems::get_item</code></a> and <a href="struct.RegisteredItems.html#method.get_item_mut" title="method rust_patterns::plugins::item_registry::RegisteredItems::get_item_mut"><code>RegisteredItems::get_item_mut</code></a>
methods, which automatically instantiate the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> <em>instance</em> if it has
not yet been initialized. Note that we intentionally do not call the <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a>
struct a “registry” because it is not necessarily a singleton. In fact, we might have many
<a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> instances each holding <code>RegisteredItem</code> instances it owns. “The registry”
that records which <code>RegisteredItem</code> types exist is purely abstract; depending on the underlying
implementation, there might not be any actual list of which <code>RegisteredItem</code> types exist at all!</p>
<p>A <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> need not actually be a singleton, but it, or rather its <em>type</em>, is only ever
<em>registered</em> once at runtime; that is, its <code>index</code>, which is shared among all instances of the
type, is initialized only once. This allows a “registered item” type to have “singleton metadata”
<a href="#note1">¹</a> associated with it in addition to whatever instance data it needs. As already mentioned,
at minimum each <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> knows its own <code>index</code>, which is used to access the item from
the owning <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> container via simple indexing into a vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s.
(See the <a href="../index.html" title="mod rust_patterns::plugins">‘plugins’ module</a> for more details about implementation.)</p>
<h3 id="q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data"><a class="doc-anchor" href="#q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data">§</a>Q: Wait, aren’t you just talking about static variables? Or, aren’t you just talking about lazy initialization of static data?</h3>
<p>A: No, I am describing an interface for <em>automatic</em> discovery of special types
and, (though only incidentally) the initialization of their static data. How rich
the static data is depends entirely on your use case, so long as it at minimum has
an <code>index</code> field to make accessing instances of the items in the owning container easy.</p>
<h3 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h3>
<p><a name="note1">1.</a>
This is usually just called <em>static</em> data, or data in a <em>static variable</em>, but I am trying
to avoid any assumptions about when this data is initialized and whether it is mutable.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems">Registered<wbr>Items</a></dt></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX">NEXT_<wbr>ITEM_<wbr>INDEX</a></dt><dd>Global item index counter, keeps track of the index that will be assigned to the next item that
requests an index. Equivalently, holds a <em>count</em> of the number of items currently registered.</dd><dt><a class="static" href="static.REGISTERED_ITEMS.html" title="static rust_patterns::plugins::item_registry::REGISTERED_ITEMS">REGISTERED_<wbr>ITEMS</a></dt><dd>For simple applications, just knowing how many items are registered is
enough, and that information is already captured in <a href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX"><code>NEXT_ITEM_INDEX</code></a>. In
more sophisticated implementations, we would want to store metadata about the
items that are registered. For example, we might want to track dependencies
between registered items. We could store that metadata in a static variable,
or we could have a global data store like the following.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem">Registered<wbr>Item</a></dt><dd>A trait for items that can be registered (<code>DataPlugin</code>, <code>PersonProperty</code>)</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.add_to_registry.html" title="fn rust_patterns::plugins::item_registry::add_to_registry">add_<wbr>to_<wbr>registry</a></dt><dd>Adds a new item to the registry. The job of this method is to create whatever “singleton”
data/metadata is associated with the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> if it doesn’t ready exist. The “registry”
is a global singleton (literally just <a href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX"><code>NEXT_ITEM_INDEX</code></a> in this implementation), so it is
enough to know the concrete type of the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>. For this illustration, the only singleton
metadata that is instantiated is the item’s index, which we return in case the caller wants it.</dd><dt><a class="fn" href="fn.get_data_plugin_count.html" title="fn rust_patterns::plugins::item_registry::get_data_plugin_count">get_<wbr>data_<wbr>plugin_<wbr>count</a></dt><dt><a class="fn" href="fn.initialize_item_index.html" title="fn rust_patterns::plugins::item_registry::initialize_item_index">initialize_<wbr>item_<wbr>index</a></dt><dd>Acquires a global lock on the next available plugin index, but only increments
it if we successfully initialize the provided index. The <code>index</code> of a registered
item is assigned at runtime but only once per type. It’s possible for a single
type to attempt to initialize its index multiple times from different threads,
which is why all this synchronization is required. However, the overhead
is negligible, as this initialization only happens once upon first access.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BxRegisteredItem.html" title="type rust_patterns::plugins::item_registry::BxRegisteredItem">BxRegistered<wbr>Item</a></dt><dd>A boxed <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a></dd></dl></section></div></main></body></html>