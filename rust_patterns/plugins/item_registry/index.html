<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Registry Pattern"><title>rust_patterns::plugins::item_registry - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rust_patterns" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module item_registry</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../rust_patterns/index.html">rust_<wbr>patterns</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module item_<wbr>registry</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-registry-pattern" title="The Registry Pattern">The Registry Pattern</a><ul><li><a href="#q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data" title="Q: Wait, aren‚Äôt you just talking about static variables? Or, aren‚Äôt you just talking about lazy initialization of static data?">Q: Wait, aren‚Äôt you just talking about static variables? Or, aren‚Äôt you just talking about lazy initialization of static data?</a></li><li><a href="#notes" title="Notes">Notes</a></li></ul></li><li><a href="#design-options-for-the-registry-pattern" title="Design Options for the Registry Pattern">Design Options for the Registry Pattern</a><ul><li><a href="#design-dimensions-for-widgets-and-widgetstores" title="Design Dimensions for `Widget`s and `WidgetStore`s">Design Dimensions for <code>Widget</code>s and <code>WidgetStore</code>s</a></li><li><a href="#multiple-registries-for-different-thing-categories-vs-a-single-registry-for-all-generic-registered-items" title="Multiple registries for different thing categories vs. a single registry for all (Generic) Registered Items">Multiple registries for different thing categories vs. a single registry for all (Generic) Registered Items</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rust_<wbr>patterns::<wbr>plugins</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">rust_patterns</a>::<wbr><a href="../index.html">plugins</a></div><h1>Module <span>item_<wbr>registry</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rust_patterns/plugins/item_registry.rs.html#1-785">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="the-registry-pattern"><a class="doc-anchor" href="#the-registry-pattern">¬ß</a>The Registry Pattern</h2>
<p>The <em>registry pattern</em> is a plugin-like pattern for managing a collection of
<a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> instances such that discovery of items is automatic/implicit.</p>
<p>For our use case, the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s are lazily registered (the allocation or
instantiation of <em>static</em> data) and instantiated (for <em>instance</em> data), but this is not
an essential part of the pattern. What <em>is</em> essential is that the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s
are automatically discovered, <em>even if they are defined in external crates</em>.</p>
<blockquote>
<p><strong>Note:</strong> If you are happy with the <em>lazy</em> discovery of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s, then you
can get away with a simpler implementation that uses neither ‚Äúrun before <code>main()</code>‚Äù nor
‚Äúdistributed slice‚Äù mechanisms (see <a href="../index.html" title="mod rust_patterns::plugins">‚Äòplugins‚Äô module</a> for discussion).
There is a trade-off: You need a mechanism for interior mutability of <code>RegisteredItems</code>
(the owner of the item instances) if you want to initialize the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> on
first access, because you don‚Äôt know how many <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> types there are globally
when <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> is constructed and thus don‚Äôt know how big the vector should be.</p>
</blockquote>
<p>In the simplest formulation, the ‚Äúregistry pattern‚Äù is just a vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s, one instance for each concrete <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> type that exists,
each one of which having a static <code>index</code> variable in which is stored its position in
the vector that owns it. We just provide a mechanism for assigning the indices to
the concrete <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> types at runtime in a logically consistent and thread-safe way
that doesn‚Äôt require explicit knowledge of every <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> type that exists. To recap: We have one item instance per concrete <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>  type per store.</p>
<p>In the next section we go into much more detail about the design decisions one has to make for any given implementation of the registry pattern. In that section we will point out which decisions we‚Äôve made for the example we are illustrating in the code provided here, but here‚Äôs a brief rundown of the main points: We define the <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> struct as a wrapper type around the vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>
instances to provide convenient [<code>RegisteredItems::get_item</code>] and [<code>RegisteredItems::get_item_mut</code>]
methods, which automatically instantiate the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> <em>instance</em> if it has
not yet been initialized. Note that we intentionally do not call the <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a>
struct a ‚Äúregistry‚Äù because it is not necessarily a singleton. In fact, we might have many
<a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> instances each holding <code>RegisteredItem</code> instances it owns. ‚ÄúThe registry‚Äù
that records which <code>RegisteredItem</code> types exist is purely abstract; depending on the underlying
implementation, there might not be any actual list of which <code>RegisteredItem</code> types exist at all!</p>
<p>A <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> need not actually be a singleton, but it, or rather its <em>type</em>, is only ever
<em>registered</em> once at runtime; that is, its <code>index</code>, which is shared among all instances of the
type, is initialized only once (in a <code>ctor</code>). This allows a ‚Äúregistered item‚Äù type to have ‚Äúsingleton metadata‚Äù
<a href="#note1">¬π</a> associated with it in addition to whatever instance data it needs. As already mentioned,
at minimum each <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> knows its own <code>index</code>, which is used to access the item from
the owning <a href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems"><code>RegisteredItems</code></a> container via simple indexing into a vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s.
(See the <a href="../index.html" title="mod rust_patterns::plugins">‚Äòplugins‚Äô module</a> for more details about implementation.)</p>
<h3 id="q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data"><a class="doc-anchor" href="#q-wait-arent-you-just-talking-about-static-variables-or-arent-you-just-talking-about-lazy-initialization-of-static-data">¬ß</a>Q: Wait, aren‚Äôt you just talking about static variables? Or, aren‚Äôt you just talking about lazy initialization of static data?</h3>
<p>A: No, I am describing an interface for <em>automatic</em> discovery of special types
and, (though only incidentally) the initialization of their static data. How rich
the static data is depends entirely on your use case, so long as it at minimum has
an <code>index</code> field to make accessing instances of the items in the owning container easy.</p>
<h3 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>Notes</h3>
<p><a name="note1">1.</a>
This is usually just called <em>static</em> data, or data in a <em>static variable</em>, but I am trying
to avoid any assumptions about when this data is initialized and whether it is mutable.</p>
<h2 id="design-options-for-the-registry-pattern"><a class="doc-anchor" href="#design-options-for-the-registry-pattern">¬ß</a>Design Options for the Registry Pattern</h2>
<p>In this section we explore in detail the different design choices one must make when implementing the registry pattern. We will call the <code>RegisteredItem</code> types of a <em>particular</em> implementation of the registry pattern the <code>Widget</code> types, or similar made up name. The owner will be some type wrapping a vector, which we‚Äôll call the <code>WidgetStore</code>, or some variant of <code>*Store</code>.</p>
<h3 id="design-dimensions-for-widgets-and-widgetstores"><a class="doc-anchor" href="#design-dimensions-for-widgets-and-widgetstores">¬ß</a>Design Dimensions for <code>Widget</code>s and <code>WidgetStore</code>s</h3>
<p>Below is my attempt at carving up the design space for our registry pattern implementation with a few alternatives listed for each. I‚Äôm using the phrase <em>dimension</em> to refer to the major orthogonal design choices that need to be made about our container. By <em>orthogonal</em> I mean a choice in one dimension does not depend on a choice in another dimension. In actual practice, implementation choices in one dimension may affect implementation in another dimension, so this independence is approximate and ‚Äúleaky‚Äù.</p>
<p>All registered items that participate in the same registry pattern implementation must share the semantics implied by these design choices to avoid significant complexity explosion.</p>
<p><strong>Initialization time</strong></p>
<ul>
<li>In a singleton at program start (a la ‚Äúdistributed slice‚Äù, prototype style)</li>
<li>Upon <code>WidgetStore</code> creation (an instance for each <code>Widget</code> type that exists is eagerly created)</li>
<li>Lazily, e.g. upon first access in <code>WidgetStore</code>. The ‚Äúslots‚Äù in the owning <code>WidgetStore</code> are occupied by <code>OnceCell</code>s</li>
<li>Something else? E.g. super lazily: upon write access in <code>WidgetStore</code>.</li>
</ul>
<p><em>In this example:</em> We lazily instantiate <code>Widget</code>s upon first access. We use <code>ctor</code> magic to know how many ‚Äúslots‚Äù the <code>WidgetStore</code> needs to allocate.</p>
<p><strong>Ownership semantics:</strong> Specific to <code>WidgetStore</code>‚Äôs relationship to <code>Widget</code> values, <em>not</em> to views client code have into the data.</p>
<ul>
<li><code>Widget</code>s are owned by the <code>WidgetStore</code> which gives out regular mutable or immutable references</li>
<li>A <code>WidgetStore</code> is either literally or essentially a singleton (possibly a naked ‚Äúdistributed slice‚Äù), only one instance of each <code>Widget</code> type is created globally.</li>
<li><code>Widget</code>s are shared, stored in <code>Arc</code>/<code>Rc</code> or <code>Cow</code> types.</li>
<li><code>Widget</code>s are <code>Copy</code> types</li>
<li>Move semantics. I‚Äôm not sure what the use case would be, but it‚Äôs possible to move <code>Widget</code> instances out of the <code>WidgetStore</code>.</li>
</ul>
<p><em>In this example:</em> <code>Widget</code>s are owned by the <code>WidgetStore</code> which gives out regular mutable or immutable references</p>
<p><strong>Interior mutability</strong></p>
<ul>
<li>‚Äúdefault‚Äù semantics: <code>Widget</code>s are owned by the <code>WidgetStore</code>, which is in turn owned by the <code>Context</code> (say), and they are all mutable or immutable at once accordingly.</li>
<li><code>WidgetStore</code> lives in a <code>RefCell</code>, so entire store is mutable at once or immutable at once</li>
<li><code>WidgetStore</code> holds individual <code>Widget</code>s in <code>RefCell</code>s, so multiple distinct <code>Widget</code>s can be simultaneously mutated</li>
<li><code>Widget</code>s are <code>Copy</code> types, so they can be copied around and mutated in place (possibly as atomic types)</li>
<li><code>Widget</code>s implement their own interior mutability</li>
</ul>
<p><em>In this example:</em> ‚Äúdefault‚Äù semantics (modulo <code>OnceCell</code>‚Äôs internal mechanisms); Mutation requires mutable access to the <code>WidgetStore</code></p>
<p><strong>Access control:</strong> what ‚Äúviews‚Äù into the data are enabled</p>
<ul>
<li>Client code get‚Äôs ‚Äúdirect‚Äù access to a <code>&amp;Widget</code> or <code>&amp;mut Widget</code></li>
<li>Client code passes a closure to a <code>with_widget</code> method, which closure is passed a <code>&amp;Widget</code>; and similarly for mutable variant</li>
<li><code>WidgetStore</code> provides rich API for interacting with <code>Widget</code>s, e.g. <code>WidgetStore::froculate_widget::&lt;Sprocket&gt;()</code> froculate‚Äôs a widget on the caller‚Äôs behalf. (We generally do this with <code>DataPlugin</code>s, for example.)</li>
<li>Pass out <code>Ref&lt;'a, Widget&gt;</code>s / <code>RefMut&lt;'a, Widget&gt;</code>s  to client code, which implement <code>Deref</code>/<code>DerefMut</code> to <code>&amp;Widget</code>/<code>&amp;mut Widget</code></li>
<li><code>Widget</code>s have <code>Copy</code> semantics, <code>WidgetStore::get()</code> returns a copy of the stored <code>Widget</code>. Have a corresponding <code>WidgetStore::set()</code> instead of <code>WidgetStore::get_mut()</code> with reference semantics.</li>
<li>YOLO raw pointers ü§£</li>
</ul>
<p><em>In this example:</em> Client code gets ‚Äúdirect‚Äù access to a <code>&amp;Widget</code> or <code>&amp;mut Widget</code>.</p>
<p><strong>Other Dimensions:</strong> Some other dimensions I don‚Äôt have much to say about.</p>
<ul>
<li><strong>Type Discovery:</strong> We want ‚Äúautomatic‚Äù discovery, but some designs can get away with not using <code>ctor</code>/<code>linkme</code> tricks, in particular when discovery can happen on an as-needed (we ‚Äúdiscover‚Äù <code>ConcreteWidget</code> only when <code>WidgetStore::get::&lt;ConcreteWidget&gt;()</code> is called); see notes below. This example uses <code>ctor</code> to know how many concrete <code>Widget</code> types there are globally and to assign each an index.</li>
<li><strong>Concurrency Model:</strong> In this example, we take care to initialize each <code>Widget</code> type‚Äôs index in a thread-safe way but otherwise don‚Äôt share access across thread boundaries.</li>
<li><strong>Lifetime Model:</strong> How long are <code>Widget</code> and <code>WidgetStore</code> instances expected to live? This implementation makes no assumptions.</li>
</ul>
<p><strong>‚ÄúLeaky‚Äù Implementation Bits:</strong></p>
<ul>
<li><code>OnceCell</code> has its own interior mutability mechanism; same with <code>inventory</code>, others; though they can be optimized for specific use cases (e.g. <code>OnceCell</code> is fast to access after initialization)</li>
<li>If <code>WidgetStore</code> does not need to be immutable, or if it or its wrapped vector can live in a <code>RefCell</code>, then magic <code>ctor</code>/<code>linkme</code> mechanisms are not necessary, because we don‚Äôt have to know the total count of all <code>Widget</code> types upon <code>WidgetStore</code> creation‚Äìwe can grow the vector as needed.</li>
<li>If <code>WidgetStore</code> needs to be immutable, then we need to know the total count of all <code>Widget</code> types upon <code>WidgetStore</code> creation in order to allocate enough ‚Äúslots‚Äù for all the <code>Widget</code> type <em>even if we defer <code>Widget</code> creation by using <code>OnceCell</code>s</em>.
<ul>
<li><code>OnceCell</code>s push (a fast form of) interior mutability out from the <code>Context</code> or <code>WidgetStore</code> level to the individual <code>Widget</code> level</li>
<li>Eager initialization is an alternative to <code>OnceCell</code> and isn‚Äôt necessarily harder to implement, since you already pay the price of fancy linker tricks for the <code>OnceCell</code> solution.</li>
</ul>
</li>
</ul>
<h3 id="multiple-registries-for-different-thing-categories-vs-a-single-registry-for-all-generic-registered-items"><a class="doc-anchor" href="#multiple-registries-for-different-thing-categories-vs-a-single-registry-for-all-generic-registered-items">¬ß</a>Multiple registries for different <em>thing</em> categories vs. a single registry for all (Generic) Registered Items</h3>
<p>We can imagine two different approaches to how many implementations of the registry pattern are in a given project:</p>
<ol>
<li>A single implementation of the registry pattern could conceivably be generic over every category of <em>thing</em> that can be registered, or at least every category that matches all of your choices for you have made in all of the dimensions listed in the previous section.
<ul>
<li>
<p>Unifies the storage and access for <code>Widget</code>s, <code>Gadget</code>s, <code>Blogets</code>, <code>Sprockets</code>, ‚Ä¶, potentially lots of disparate categories of objects.</p>
</li>
<li>
<p>Minimizes lines of code, API</p>
</li>
</ul>
</li>
<li>You have separate implementations in your project of the registry pattern for each category even if the design choices in all dimensions of the previous section are the same. For example, you might implement the registry pattern for your <code>Widget</code> system and then have a separate independent implementation of the registry pattern for your <code>Gadget</code> system.
<ul>
<li>Different public API for different categories of objects</li>
<li>If we want to change the storage / ownership / access semantics for a category of objects, it‚Äôs already distinguished from other categories and has its own API.</li>
</ul>
</li>
</ol>
<p>My advice is to choose (2) almost always. Superficial implementation features are generally poor decomposition criteria. A <code>Widget</code> system and a <code>Gadget</code> system should generally not be artificially coupled.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="struct" href="struct.RegisteredItems.html" title="struct rust_patterns::plugins::item_registry::RegisteredItems">Registered<wbr>Items</a></dt><dd>A wrapper around a vector of <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>s.</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="static" href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX">NEXT_<wbr>ITEM_<wbr>INDEX</a></dt><dd>Global item index counter, keeps track of the index that will be assigned to the next item that
requests an index. Equivalently, holds a <em>count</em> of the number of items currently registered.</dd><dt><a class="static" href="static.REGISTERED_ITEMS.html" title="static rust_patterns::plugins::item_registry::REGISTERED_ITEMS">REGISTERED_<wbr>ITEMS</a></dt><dd>For simple applications, just knowing how many items are registered is
enough, and that information is already captured in <a href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX"><code>NEXT_ITEM_INDEX</code></a>. In
more sophisticated implementations, we would want to store metadata about the
items that are registered.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="trait" href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem">Registered<wbr>Item</a></dt><dd>A trait for items that can be registered (<code>DataPlugin</code>, <code>PersonProperty</code>)</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="fn" href="fn.add_to_registry.html" title="fn rust_patterns::plugins::item_registry::add_to_registry">add_<wbr>to_<wbr>registry</a></dt><dd>Adds a new item to the registry. The job of this method is to create whatever ‚Äúsingleton‚Äù
data/metadata is associated with the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a> if it doesn‚Äôt already exist. The ‚Äúregistry‚Äù
is a global singleton (literally just <a href="static.NEXT_ITEM_INDEX.html" title="static rust_patterns::plugins::item_registry::NEXT_ITEM_INDEX"><code>NEXT_ITEM_INDEX</code></a> in this implementation), so it is
enough to know the concrete type of the <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a>. For this illustration, the only singleton
metadata that is instantiated is the item‚Äôs index, which we return in case the caller wants it.</dd><dt><a class="fn" href="fn.get_registered_item_count.html" title="fn rust_patterns::plugins::item_registry::get_registered_item_count">get_<wbr>registered_<wbr>item_<wbr>count</a></dt><dd>An accessor for <code>NEXT_ITEM_INDEX</code></dd><dt><a class="fn" href="fn.initialize_item_index.html" title="fn rust_patterns::plugins::item_registry::initialize_item_index">initialize_<wbr>item_<wbr>index</a></dt><dd>Encapsulates the synchronization logic for initializing an item‚Äôs index.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="type" href="type.BxRegisteredItem.html" title="type rust_patterns::plugins::item_registry::BxRegisteredItem">BxRegistered<wbr>Item</a></dt><dd>A boxed <a href="trait.RegisteredItem.html" title="trait rust_patterns::plugins::item_registry::RegisteredItem"><code>RegisteredItem</code></a></dd></dl></section></div></main></body></html>